/*
 Leaflet.BigImage (https://github.com/pasichnykvasyl/Leaflet.BigImage).
 (c) 2020, Vasyl Pasichnyk, pasichnykvasyl (Oswald)
*/

 !function(t, i) {
    "function"==typeof define&&define.amd?define(["leaflet"], t): "object"==typeof exports&&(module.exports=t(require("leaflet"))), void 0 !==i&&i.L&&(i.L.YourPlugin=t(L))
}

(function(t) {
    t.Control.BigImage=t.Control.extend( {
        options: {
            position: "topright", title:"Get image", printControlLabel:"⤵️", printControlClasses:[], printControlTitle:"Get image", _unicodeClass:"bigimage-unicode-icon", maxScale:10, minScale:1, inputTitle:"Choose scale:", downloadTitle:"Download"
        }
        , onAdd:function(t) {
            this._map=t;
            let i=this.options.printControlTitle, e=this.options.printControlLabel, n=this.options.printControlClasses;
            return -1 !=e.indexOf("&")&&n.push(this.options._unicodeClass), this._createControl(e, i, n, this._click, this)
        }
        , _click:function(t) {
            this._container.classList.add("leaflet-control-layers-expanded"), this._containerParams.style.display="", this._controlPanel.classList.add("bigimage-unicode-icon-disable")
        }
        , _createControl:function(i, e, n, o, s) {
            this._container=document.createElement("div"), this._container.id="print-container", this._container.classList.add("leaflet-bar"), this._containerParams=document.createElement("div"), this._containerParams.id="print-params", this._containerParams.style.display="none", this._createCloseButton();
            let a=document.createElement("h6");
            return a.style.width="100%", a.innerHTML=this.options.inputTitle, this._containerParams.appendChild(a), this._createScaleInput(), this._createDownloadButton(), this._container.appendChild(this._containerParams), this._createControlPanel(n, s, i, e, o), t.DomEvent.disableScrollPropagation(this._container), t.DomEvent.disableClickPropagation(this._container), this._container
        }
        , _createDownloadButton:function() {
            this._downloadBtn=document.createElement("div"), this._downloadBtn.classList.add("download-button"), this._downloadBtn=document.createElement("div"), this._downloadBtn.classList.add("download-button"), this._downloadBtn.innerHTML=this.options.downloadTitle, this._downloadBtn.addEventListener("click", ()=> {
                let t=this._scaleInput.value;
                if( !t||t<this.options.minScale||t>this.options.maxScale) {
                    this._scaleInput.value=this.options.minScale;
                    return
                }
                this._containerParams.classList.add("print-disabled"), this._loader.style.display="block", this._print()
            }
            ), this._containerParams.appendChild(this._downloadBtn)
        }
        , _createScaleInput:function() {
            this._scaleInput=document.createElement("input"), this._scaleInput.style.width="100%", this._scaleInput.type="number", this._scaleInput.value=this.options.minScale, this._scaleInput.min=this.options.minScale, this._scaleInput.max=this.options.maxScale, this._scaleInput.id="scale", this._containerParams.appendChild(this._scaleInput)
        }
        , _createCloseButton:function() {
            let t=document.createElement("div");
            t.classList.add("close"), t.innerHTML="&times;", t.addEventListener("click", ()=> {
                this._container.classList.remove("leaflet-control-layers-expanded"), this._containerParams.style.display="none", this._controlPanel.classList.remove("bigimage-unicode-icon-disable")
            }
            ), this._containerParams.appendChild(t)
        }
        , _createControlPanel:function(i, e, n, o, s) {
            let a=document.createElement("a");
            a.innerHTML=n, a.id="print-btn", a.setAttribute("title", o), i.forEach(function(t) {
                a.classList.add(t)
            }
            ), t.DomEvent.on(a, "click", s, e), this._container.appendChild(a), this._controlPanel=a, this._loader=document.createElement("div"), this._loader.id="print-loading", this._container.appendChild(this._loader)
        }
        , _getLayers:function(i) {
            let e=this, n=[];
            e._map.eachLayer(function(i) {
                n.push(new Promise(n=> {
                    try {
                        i instanceof t.Marker?e._getMarkerLayer(i, n): i instanceof t.TileLayer?e._getTileLayer(i, n):i instanceof t.Circle?(e.circles[i._leaflet_id]||(e.circles[i._leaflet_id]=i), n()):i instanceof t.Path?e._getPathLayer(i, n):n()
                    }
                    catch(o) {
                        console.log(o), n()
                    }
                }
                ))
            }
            ), Promise.all(n).then(()=> {
                i()
            }
            )
        }
        , _getTileLayer:function(i, e) {
            let n=this;
            n.tiles=[], n.tileSize=i._tileSize.x, n.tileBounds=t.bounds(n.bounds.min.divideBy(n.tileSize)._floor(), n.bounds.max.divideBy(n.tileSize)._floor());
            for(let o=n.tileBounds.min.y;
            o<=n.tileBounds.max.y;
            o++)for(let s=n.tileBounds.min.x;
            s<=n.tileBounds.max.x;
            s++)n.tiles.push(new t.Point(s, o));
            let a=[];
            n.tiles.forEach(e=> {
                let o=e.clone();
                i._adjustTilePoint&&i._adjustTilePoint(e);
                let s=o.scaleBy(new t.Point(n.tileSize, n.tileSize)).subtract(n.bounds.min);
                e.y<0||a.push(new Promise(t=> {
                    n._loadTile(e, s, i, t)
                }
                ))
            }
            ), Promise.all(a).then(()=> {
                e()
            }
            )
        }
        , _loadTile:function(t, i, e, n) {
            let o=this, s=t.x+":"+t.y+":"+o.zoom;
            o.tilesImgs[e._leaflet_id]= {}
            ;
            let a=new Image;
            a.crossOrigin="Anonymous", a.onload=function() {
                o.tilesImgs[e._leaflet_id][s]||(o.tilesImgs[e._leaflet_id][s]= {
                    img: a, x:i.x, y:i.y
                }
                ), n()
            }
            , a.src=e.getTileUrl(t)
        }
        , _getMarkerLayer:function(i, e) {
            let n=this;
            if(n.markers[i._leaflet_id]) {
                e();
                return
            }
            let o=n._map.project(i._latlng);
            if(o=o.subtract(new t.Point(n.bounds.min.x, n.bounds.min.y)), i.options.icon&&i.options.icon.options&&i.options.icon.options.iconAnchor&&(o.x-=i.options.icon.options.iconAnchor[0], o.y-=i.options.icon.options.iconAnchor[1]),  !n._pointPositionIsNotCorrect(o)&&i._icon.src) {
                let s=new Image;
                s.crossOrigin="Anonymous", s.src=i._icon.src, s.onload=function() {
                    n.markers[i._leaflet_id]= {
                        img: s, x:o.x, y:o.y
                    }
                    , e()
                }
                ;
                return
            }
            if(n._pointPositionIsNotCorrect(o)|| !i._icon.innerHTML||i._icon.src)e();
            else {
                let a=new Text(i._icon.innerHTML);
                n.markers[i._leaflet_id]= {
                    html: a, x:o.x, y:o.y
                }
                , e()
            }
        }
        , _pointPositionIsNotCorrect:function(t) {
            return t.x<0||t.y<0||t.x>this.canvas.width||t.y>this.canvas.height
        }
        , _getPathLayer:function(i, e) {
            let n=this, o=0, s=[];
            if(i._mRadius|| !i._latlngs) {
                e();
                return
            }
            let a=i.options.fill?i._latlngs[0]:i._latlngs;
            Array.isArray(a[0])&&(a=a.flat()), a.forEach(i=> {
                let e=n._map.project(i);
                e=e.subtract(new t.Point(n.bounds.min.x, n.bounds.min.y)), s.push(e), e.x<n.canvas.width&&e.y<n.canvas.height&&(o=1)
            }
            ), o&&(n.path[i._leaflet_id]= {
                parts: s, closed:i.options.fill, options:i.options
            }
            ), e()
        }
        , _changeScale:function(t) {
            if( !t||t<=1)return 0;
            let i=(this.bounds.max.x-this.bounds.min.x)/2*(t-1), e=(this.bounds.max.y-this.bounds.min.y)/2*(t-1);
            this.bounds.min.x-=i, this.bounds.min.y-=e, this.bounds.max.x+=i, this.bounds.max.y+=e, this.canvas.width*=t, this.canvas.height*=t
        }
        , _drawPath:function(t) {
            let i=this;
            i.ctx.beginPath();
            let e=0, n=t.options;
            t.parts.forEach(t=> {
                i.ctx[e++?"lineTo": "moveTo"](t.x, t.y)
            }
            ), t.closed&&i.ctx.closePath(), this._feelPath(n)
        }
        , _drawText:function(t, i) {
            let e=this.ctx.fillStyle;
            this.ctx.font="regular 16px arial", this.ctx.fillStyle="white", this.ctx.fillText(t.html.nodeValue, t.x, t.y), this.ctx.fillStyle=e
        }
        , _drawCircle:function(i, e) {
            if(i._empty())return;
            let n=this._map.project(i._latlng);
            n=n.subtract(new t.Point(this.bounds.min.x, this.bounds.min.y));
            let o=Math.max(Math.round(i._radius), 1), s=(Math.max(Math.round(i._radiusY), 1)||o)/o;
            1 !==s&&(this.ctx.save(), this.scale(1, s)), this.ctx.beginPath(), this.ctx.arc(n.x, n.y/s, o, 0, 2*Math.PI,  !1), 1 !==s&&this.ctx.restore(), this._feelPath(i.options)
        }
        , _feelPath:function(t) {
            t.fill&&(this.ctx.globalAlpha=t.fillOpacity, this.ctx.fillStyle=t.fillColor||t.color, this.ctx.fill(t.fillRule||"evenodd")), t.stroke&&0 !==t.weight&&(this.ctx.setLineDash&&this.ctx.setLineDash(t&&t._dashArray||[]), this.ctx.globalAlpha=t.opacity, this.ctx.lineWidth=t.weight, this.ctx.strokeStyle=t.color, this.ctx.lineCap=t.lineCap, this.ctx.lineJoin=t.lineJoin, this.ctx.stroke())
        }
        , _print: function() {
    let t = this;
    t.tilesImgs = {};
    t.markers = {};
    t.path = {};
    t.circles = {};
    let i = t._map.getSize();
    t.zoom = t._map.getZoom();
    t.bounds = t._map.getPixelBounds();
    t.canvas = document.createElement("canvas");
    t.canvas.width = i.x;
    t.canvas.height = i.y;
    t.ctx = t.canvas.getContext("2d");

    this._changeScale(document.getElementById("scale").value);

    let points = [
        { x: parseFloat(document.getElementById("LocationPointX0").value), y: parseFloat(document.getElementById("LocationPointY0").value) },
        { x: parseFloat(document.getElementById("LocationPointX1").value), y: parseFloat(document.getElementById("LocationPointY1").value) },
        { x: parseFloat(document.getElementById("LocationPointX2").value), y: parseFloat(document.getElementById("LocationPointY2").value) },
        { x: parseFloat(document.getElementById("LocationPointX3").value), y: parseFloat(document.getElementById("LocationPointY3").value) }
    ];

    let center = points.reduce((acc, point) => ({
        x: acc.x + point.x / points.length,
        y: acc.y + point.y / points.length
    }), { x: 0, y: 0 });

    points.sort((a, b) => {
        let angleA = Math.atan2(a.y - center.y, a.x - center.x);
        let angleB = Math.atan2(b.y - center.y, b.x - center.x);
        return angleA - angleB;
    });

    const padding = 20;

    let point0 = t._map.latLngToContainerPoint([points[0].y, points[0].x]);
    let point1 = t._map.latLngToContainerPoint([points[1].y, points[1].x]);
    let point2 = t._map.latLngToContainerPoint([points[2].y, points[2].x]);
    let point3 = t._map.latLngToContainerPoint([points[3].y, points[3].x]);

    let minX = Math.min(point0.x, point1.x, point2.x, point3.x) - padding;
    let minY = Math.min(point0.y, point1.y, point2.y, point3.y) - padding;
    let maxX = Math.max(point0.x, point1.x, point2.x, point3.x) + padding;
    let maxY = Math.max(point0.y, point1.y, point2.y, point3.y) + padding;
    let cropWidth = maxX - minX;
    let cropHeight = maxY - minY;

    new Promise(function(i, e) {
        t._getLayers(i);
    }).then(() => new Promise((i, e) => {
        for (let [n, o] of Object.entries(t.tilesImgs))
            for (let [s, a] of Object.entries(o))
                t.ctx.drawImage(a.img, a.x, a.y, t.tileSize, t.tileSize);
        for (let [l, c] of Object.entries(t.path))
            t._drawPath(c);
        for (let [r, h] of Object.entries(t.markers))
            h instanceof HTMLImageElement || h.img ? t.ctx.drawImage(h.img, h.x, h.y) : t._drawText(h, h.x, h.y);
        for (let [d, p] of Object.entries(t.circles))
            t._drawCircle(p);
        i();
    })).then(() => {
        let croppedCanvas = document.createElement("canvas");
        croppedCanvas.width = cropWidth;
        croppedCanvas.height = cropHeight;
        let croppedCtx = croppedCanvas.getContext("2d");

        croppedCtx.drawImage(t.canvas, minX, minY, cropWidth, cropHeight, 0, 0, cropWidth, cropHeight);

        croppedCtx.fillStyle = 'rgba(255, 0, 0, 0.3)';
        croppedCtx.beginPath();
        croppedCtx.moveTo(point0.x - minX, point0.y - minY);
        croppedCtx.lineTo(point1.x - minX, point1.y - minY);
        croppedCtx.lineTo(point2.x - minX, point2.y - minY);
        croppedCtx.lineTo(point3.x - minX, point3.y - minY);
        croppedCtx.closePath();
        croppedCtx.fill();

        croppedCanvas.toBlob((blob) => {
            const randomFileName = `mapExport_${Date.now()}.png`;
            const file = new File([blob], randomFileName, { type: "image/png" });
            const dataTransfer = new DataTransfer();
            dataTransfer.items.add(file);
            document.getElementById('image').files = dataTransfer.files;
        });

        t._containerParams.classList.remove("print-disabled");
        t._loader.style.display = "none";
    });
}





    }
    ), t.control.bigImage=function(i) {
        return new t.Control.BigImage(i)
    }
}

, window);